<html>
<head> <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="stylesheet" href="https://latex.vercel.app/style.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css"/><script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]}};</script>

<title>Fractal Geometry Lab 2 Report</title>

</head>
	
<body id="top">




  <header>
    <h1>Fractal Geometry Lab Report</h1>
    <p class="author">
      [Gabrielle Griffith] <br />
      [February 12, 2025]
    </p>
  </header>
  


  <main>
    <article class="indent-pars">
      
      <!-- INTRODUCTION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="introduction">
        <h2>Introduction</h2>
        <p>
         In the lab for module 3, we will be exploring how to create triangles and other figures that come with it. Initially, I will show you how to produce a triangle and then go further to show you how to produce a Sierpinski triangle. With this produced code, I will attempt to expand the code to make two connected Sierpinski triangles. Aside from this, I will manipulate the size and the color of the figures, as I have done in previous labs. The code that changes the size of the figures will be shown and explained.
        </p>
      </section>

	    
      <section id="results">
        <h2>Results &amp; Analysis </h2>
        <p> I will begin by exploring the code to produce an equilateral triangle. I want to preface by stating that the code to define the turtle function is in the link as follows : https://raw.githubusercontent.com/williamedwardhahn/fractal25/refs/heads/main/turtle_setup.py . 
I've shared two sets of code below. The first set of codes is the base equilateral triangle that was given. The second code set is when the triangle size and color are altered.   </p>


<section id="code">
	<pre><code class="language-python">new
initializeTurtle()
showturtle()

# Define the function to draw an equilateral triangle
def draw_triangle(length):
    for _ in range(3):
        forward(length)
        left(120)

# Set up the turtle
jump(300, 500)
face(90)
color('green')
length = 400
draw_triangle(length)

show()
		
	</code></pre>

<figure>
          <img
            src="equaltri.png"/>
          <figcaption>
            <strong>Figure 1: This is the product of the original code for the equilateral triangle. The triangle is drawn by the turtle and the original color is green.</strong>  
          </figcaption>
        </figure>

<section id="code">
	<pre><code class="language-python">new
initializeTurtle()
showturtle()

# Define the function to draw an equilateral triangle
def draw_triangle(length):
    for _ in range(5):
        forward(length)
        left(120)

# Set up the turtle
jump(300, 500)
face(90)
color('purple')
length = 237
draw_triangle(length)

show()
		
	</code></pre>

	<figure>
          <img
            src="equaltri.png"/>
          <figcaption>
            <strong>Figure 2: After altering the original code this was created.</strong>  
          </figcaption>
        </figure>
 <p> The code shown above is the code that I manipulated slightly. I first changed the color of the triangle to purple, specifically shown by the  color('purple') line. I noticed that the for _ in range(5) code determines the ending position of the turtle after the code is run. In Figure 1, we see that the turtle starts and stops at the same position (the left side of the triangle). When I changed the value from three to five the ending position of the turtle was at the apex of the triangle. The last alteration that I made was changing the size of the triangle from 400 to 237. This made the triangle smaller. </p>


<p> The next set of code I will display, is that of the Sierpenski triangle. Before the turtle draws this triangle we first have to define the Sierpinski triangle. This is shown in the first set of code below.</p>

	<section id="code">
	<pre><code class="language-python">new
# Define the recursive Sierpinski triangle function
def sierpinski_triangle(length, order):
    if order == 0:
        draw_triangle(length)
    else:
        sierpinski_triangle(length / 2, order - 1)
        forward(length / 2)
        sierpinski_triangle(length / 2, order - 1)
        backward(length / 2)
        left(60)
        forward(length / 2)
        right(60)
        sierpinski_triangle(length / 2, order - 1)
        left(60)
        backward(length / 2)
        right(60)

#Turtle is drawing a Sierpinski triangle		
initializeTurtle()
showturtle()

# Set up the turtle
jump(300, 500)
face(90)
color('green')

# Draw the Sierpinski triangle
length = 400
order = 4
sierpinski_triangle(length, order)

show()	
	</code></pre>

		 <figure>
          <img
            src="sierpinskitriangle.png"/>
          <figcaption>
            <strong>Figure 3</strong>  
          </figcaption>
        </figure>


<p>I presume with this code (the first block) that we are drawing multiple sets of triangles that progressively get smaller to create the fractal pattern that we are seeking. More specifically, I believe that the /2 in the line of code determines the length of the next triangle. This cuts the value length of each segment of the triangle gets cut in half. The second block of code defines the turtle so it will draw the Sierpinski code defined in the first block. 

The next set of codes below shows the manipulation of the size and color of the Sierpinski triangles as well as the size. I purposely places the turtle at the right end of each triangle to give the illusion of a continuous drawing. Notice that the x value of the jump() code is the only number that is changing. Again the turtle position was moved to the righr portion of the triangle.</p>
     
	<section id="code">
	<pre><code class="language-python">new
		initializeTurtle()
showturtle()

# Set up the turtle
jump(300, 500)
face(90)
color('pink')

# Draw the Sierpinski triangle
length = 321
order = 4
sierpinski_triangle(length, order)

# Move turtle to new position
jump(620,500)
face(90)
color('orange')

# Draw the Sierpinski triangle
length = 200
order = 4
sierpinski_triangle(length, order)

# Move turtle to a new position
jump(820,500)
face(90)
color('yellow')

# Draw the Sierpinski triangle
length = 50
order = 4
sierpinski_triangle(length, order)

show()
	</code></pre>


 <figure>
          <img
            src="tripletriangles.png"/>
          <figcaption>
            <strong>Figure 4</strong>  
          </figcaption>
        </figure>

<p>Next we will be discussing the code that produces a black-and-white version of the Sierpinski triangles. When exploring this code I noticed that the color of the image presented cannot be changed from grey. I concluded that maybe for this particular code, that is the only color that is permitted. When I changed the ax.axis() to 'on', an x-y grid was displayed on the left side and bottom of the image (as shown in figure 6).</p>

 <figure>
          <img
            src="cellularautomata.png"/>
          <figcaption>
            <strong>Figure 5: Original image of Cellular Automation but only one block</strong>  
          </figcaption>
        </figure>

 <figure>
          <img
            src="showscale.png"/>
          <figcaption>
            <strong>Figure 6: When the ax.axis() is set to 'on'.block</strong>  
          </figcaption>
        </figure>

<p>When looking at the C= np.zeros((,)).astype(int) portion of the code, I noted that increasing the size increases the interval of the scales on the plane. In other words, instead of going from zero to one hundred, it would now be greater and end at one hundred and fifty. Another observation that I made was determining how to change the position of the block that was created. When I changed the first value in the C[,] code the object moved vertically. Horizontal movement was shown after changing the second value of this code. These changes are shown in the figure below. </p>


 <figure>
          <img
            src="150150.png"/>
          <figcaption>
            <strong>Figure 7: Movement of the object and larger plot size.</strong>  
          </figcaption>
        </figure>

<p> The next image we will be looking at is the Celluar Automation of a Sierpinski triangle. With the code shown below we are able to produce a greyscle verson of the Sieroinski triangle. The triangle seems to be created with the code we discussed previously that created the square blocks. I attempted to mnipulate ths code but when I did cahnge some elements I got the same imaage being produced.</p>


<section id="code">
	<pre><code class="language-python">new
		def CA(X):

    for i in range(1,X.shape[1]-1): #row
        for j in range(1,X.shape[1]-1): #col

            N  = X[i-1,j]
            NW = X[i-1,j-1]
            NE = X[i-1,j+1]

            X[i,j] = rule[NW,N,NE]

    return X

plot(CA(C))
	</code></pre>

		
		 <figure>
          <img
            src="bwstriangle.png"/>
          <figcaption>
            <strong>Figure 8</strong>  
          </figcaption>
        </figure>

<p>The final set of code that we will be analyzing is the code that produces multiple variations of the Sierpinski triangle. The original code and image is as follows:</p>

<section id="code">
	<pre><code class="language-python">new
		for rule in [30, 62, 90, 110, 126]:
		plot(CA(C))
	</code></pre>

 <figure>
          <img
            src="30-126.png"/>
          <figcaption>
            <strong>Figure 9</strong>  
          </figcaption>
        </figure>

<p>After altering the numbers in the code, I assume that the complexity of the image changes as the number varies. Below are a few variations of the numbers changing.</p>


<figure>
          <img
            src="10-50.png"/>
          <figcaption>
            <strong>Figure 10: This is the product of for rule in [10, 20, 30, 40, 50]</strong>  
          </figcaption>
        </figure>
	
	<figure>
          <img
            src="10-150.png"/>
          <figcaption>
            <strong>Figure 11: This is the result of for rule in [10, 40, 70, 110, 150]</strong>  
          </figcaption>
        </figure>

<figure>
          <img
            src="150-500.png"/>
          <figcaption>
            <strong>Figure 12:This is the production of for rule in [150, 2450, 317, 450, 500] </strong>  
          </figcaption>
        </figure>
	</section>


	
       <section id="conclusion">
          <h2>Conclusion</h2>
        <p>
         To conclude, in this module, we began by creating a less complex figure, a triangle, to creating a fractal by the name of the Sierpinski triangle. We first manipulated the size and the color of the triangle and had the turtle draw it. Then we learned how to code the turtle to draw a Sierpinski triangle. With this code, I was able to produce three connecting Sierpinski triangles of decreasing size (and differing colors). The final code that was produced involved the use of a process called Cellular Automation. This produced a grayscale image of the Sierpinski triangle. Along with this was a code that produced a code of different complexities of the Sierpinski triangles. I displayed different values that displayed images on the same size plot.
        </p>

	       

        
