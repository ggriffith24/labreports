<html>
<head> <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="stylesheet" href="https://latex.vercel.app/style.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css"/><script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]}};</script>

<title>Fractal Geometry Lab 2 Report</title>

</head>
	
<body id="top">




  <header>
    <h1>Fractal Geometry Lab Report</h1>
    <p class="author">
      [Gabrielle Griffith] <br />
      [February 5-12, 2025]
    </p>
  </header>
  


  <main>
    <article class="indent-pars">
      
      <!-- INTRODUCTION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="introduction">
        <h2>Introduction</h2>
        <p>
         In the lab for module 2, we are exploring new patterns that the turtle follows. When we explored this in the first lab, the turtle was moving in a square path. The trace of the path was manipulated to represent the different colors. In this lab, we will explore the other patterns that can be illustrated. More specifically, we will be producing structures like the Korich Snowflake. In the following report, we will both display and explain the code explored. A section will show the code use and a small description of the results.
        </p>
      </section>


     
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	    <section id="results">
	<h2>Results and Exploration</h2>
		    <p> 
			This first line of code that is going to explore randomizes the path that is produced. This randomized walk is also defined as Brownian motion. Defined in the code below, we notice that the random_walk(steps, step_length) initializes it but there are specific parameters you can change. I have included 3 variations of the randomized path below.
		    </p>
	<section id="code">
	<pre><code class="language-python">
	import random
CODE 1:
# Step 1: Initialize the turtle canvas
canvas_width = 1000
canvas_height = 800
initializeTurtle(initial_window_size=(canvas_width, canvas_height), mode='auto')

# Step 2: Function to perform a random walk (Brownian motion)
def random_walk(steps, step_length):
    speed(0)             # Set speed to maximum for faster drawing
    penup()
    jump(450, 450)       # Start near the middle of the canvas
    pendown()

    for _ in range(steps):
        forward(step_length)               # Move forward by the step length
        right(random.uniform(-180, 180))   # Turn by a random angle between -180 and 180 degrees

# Step 3: Execute the random walk with increased steps and/or step length
steps = 1000
step_length = 10

random_walk(steps, step_length)

# Step 4: Display the result
show()
</code></pre>
 <figure>
          <img
            src="Random 1.png"
            
          />
          <figcaption>
            <strong>Figure 1:</strong> 
            
          </figcaption>
        </figure>

		 <figure>
          <img
            src="Random 2.png"
            
          />
          <figcaption>
            <strong>Figure 2:</strong> 
            
          </figcaption>
        </figure>
		 <figure>
          <img
            src="Random 3.png"
            
          />
          <figcaption>
            <strong>Figure 3:</strong> 
            
          </figcaption>
        </figure>
  <p> 
	The next set of code that is being presented, shows the turtle taking a path with what is called a Blip. The turtle starts on a straight path, travels up to an apex, and then back down to a straight path.
		    </p>
     </section>
		    <section id="code">
	<pre><code class="language-python">
initializeTurtle()
showturtle()

jump(50, 400)
face(90)

# Line with blip
forward(800 / 3)
left(60)
forward(800 / 3)
right(120)
forward(800 / 3)
left(60)
forward(800 / 3)

show()
		</code></pre>
<figure>
          <img
            src="blip.png"
            
          />
          <figcaption>
            <strong>Figure 4</strong> 
            
          </figcaption>
        </figure>
			    <p> 
	The next few sets of codes that will be displayed manipulate the different patterns that can be created with the "Blip" that was defined/shown in the previous statements. The first set of code represents the result of code that involves the overlapping of two blips. The second set of code shows the attachment of multiple blips connected, at different angles to form what closely resembles the shape of a snowflake (but it is not fully connected).
		    </p>
 </section>
		    <section id="code">
	<pre><code class="language-python">
	# Define the blip_line function
def blip_line(length, order):
    if order == 0:
        forward(length)
    else:
        blip_line(length / 3, order - 1)
        left(60)
        blip_line(length / 3, order - 1)
        right(120)
        blip_line(length / 3, order - 1)
        left(60)
        blip_line(length / 3, order - 1)

initializeTurtle()

# Draw blip lines of different orders
jump(50, 400)
face(90)
color('red')
blip_line(800, 1)  # Order 1

jump(50, 350)
face(90)
color('blue')
blip_line(800, 2)  # Order 2

show()
	</code></pre>
<figure>
          <img
            src="stacked blip.png"
            
          />
          <figcaption>
            <strong>Figure 5: In the image above we notice that there is an overlap of blips that we first discovered in the previous image. Each of the blips has a different color which can be changed in the code shown above. Additionally, the blue blip has more apexes than the red (and it is angled differently). </strong> 
            
          </figcaption>
        </figure>
  <section id="code">
	<pre><code class="language-python">
initializeTurtle()
showturtle()

jump(50, 300)
face(90)
color('green')
blip_line(800, 3)  # Order 3

show()
	</code></pre>

 <figure>
          <img
            src="partial koch snowflake.png"
            
          />
          <figcaption>
            <strong>Figure 6:</strong> This figure represents the drawing of an incomplete Koch snowflake.
            
          </figcaption>
        </figure>

 <section id="code">
	<pre><code class="language-python">
		initializeTurtle()
showturtle()

# Define the blip_line function (Koch curve)
def blip_line(length, order):
    if order == 0:
        forward(length)
    else:
        blip_line(length / 3, order - 1)
        left(60)
        blip_line(length / 3, order - 1)
        right(120)
        blip_line(length / 3, order - 1)
        left(60)
        blip_line(length / 3, order - 1)

# Draw the Koch snowflake
def koch_snowflake(length, order):
    for _ in range(3):
        blip_line(length, order)
        right(120)

# Set up the turtle
jump(250, 500)
face(0)
color('blue')

# Draw the snowflake
length = 400
order = 3
koch_snowflake(length, order)

show()
</code></pre>

	  <figure>
          <img
            src="Complete Base Koch snowflake.png"
            
          />
          <figcaption>
            <strong>Figure 7:</strong> This is the base code used to represent a fully completed Koch snowflake. We will use this code to experiment later in the document.
            
          </figcaption>
        </figure>
	 
	  
	  <p> The code is then further extended to create what is known as the Koch snowflake. This is what the first code below represents. I would now like to take this line of code and extend it to create a more fascinating image. I will attempt to manipulate the color along with possibly overlapping multiple Koch snowflakes.
	  </p>

	    <section id="code">
	<pre><code class="language-python">
initializeTurtle()
showturtle()

# Define the blip_line function (Koch curve)
def blip_line(length, order):
    if order == 0:
        forward(length)
    else:
        blip_line(length / 3, order - 1)
        left(60)
        blip_line(length / 3, order - 1)
        right(120)
        blip_line(length / 3, order - 1)
        left(60)
        blip_line(length / 3, order - 1)

# Draw the Koch snowflake
def koch_snowflake(length, order):
    for _ in range(3):
        blip_line(length, order)
        right(120)
# Function to a draw an inscribed Koch snowflake
def inscribed_koch_snowflake(length, order):
    scale_factor =1/3
    new_length = length * scale_factor

    # Move to a new starting position
    penup()
    forward(length / 2)
    left (590)
    forward(length / 4)
    right(590)
    pendown()

# Draw the inner snowflake
    koch_snowflake(new_length, order)

# Return to the original position
    penup()
    right(590)
    backward (length / 4)
    right (590)
    backward (length / 4)
    left (250)
    pendown()

# Set up the turtle
jump(250, 500)
face(0)
color('orange')

# Draw the  outer snowflake
length = 400
order = 3
koch_snowflake(length, order)

# Draw the inscribed snowflake
color ('green')
inscribed_koch_snowflake(length, order)

show()
</code></pre>

 <figure>
          <img
            src=" Inscribed Koch snowflake.png"
            
          />
          <figcaption>
            <strong>Figure 7:</strong> This is the base code used to represent a fully completed Koch snowflake. We will use this code to experiment later in the document.
            
          </figcaption>
        </figure>
		    
	  
	  <p> After utilizing ChatGPT and experimenting with the code provided, I was able to produce the image above. Initially, ChatGPT proposed a code that issued the drawing of two differing Koch snowflakes. But, the issue that I was facing was that the smaller Koch snowflake was not in the center of the larger, outer Koch snowflake. I began to experiment specifically with the left(), forward(), right(), and backward codes. I knew that these would dictate the position of the snowflake. The original values reflected those in the code displayed by the section preceding Figure __. I began by increasing the number by an interval of 100 (only the left() and right() codes). At the value of six hundred, I noticed that the snowflake was far to the right. Similarly, at the value of five hundred, the value was slightly left. Therefore, I came to the conclusion that the value needed to be between 500 and 600. The values were then changed at an interval of ten until the result of five-hundred and ninety. The smaller snowflake was now in the center of the bottom of the larger snowflake. I then attempted to change the value of the last left() code to different values but that was not repositioning the snowflake vertically. I then changed the first forward() command forward( length / 4) by an interval of 1 and realized this would solve the problem. Then I was able to perfectly place the smaller Koch snowflake in the direct center of the larger Koch snowflake.
	  
	  The final image that we were introduced to is known as the Dragon Curve. Below I will show the base code, an image of the base code as well as an image of the manipulated code. In the manipulation of this code, I changed the color and the size. When the value of the _____ code was changed ________________.</p>
      <section id="results">
      
      
        <h2>Results &amp; Conclusion</h2>
        <p>
         This module two lab had us explore the code for blips, Koch snowflakes, and Dragon curves. Most of the experimentation in this lab focused on the Koch snowflakes and the Dragon curves. I was fascinated by how we can easily alter the length by either defining a new length or writing "length / 3" or any given number. Initially, I did not think this would alter the vertical value but that is why experimentation is vital. Altering the values of left(), and right() assisted in moving the position of the snowflake horizontally.
        </p>

	       


